(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{293:function(v,_,t){"use strict";t.r(_);var e=t(1),a=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("p",[v._v("本文用来记录v-if和v-show在弹框表单中的各种坑。\n")]),v._v(" "),t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍","aria-hidden":"true"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),t("p",[v._v("    最近在开发后台管理系统时，偶然踩到了一个自己平时不以为然的坑——关于"),t("code",[v._v("v-if")]),v._v("和"),t("code",[v._v("v-show")]),v._v("在form表单使用的问题。")]),v._v(" "),t("h2",{attrs:{id:"正文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正文","aria-hidden":"true"}},[v._v("#")]),v._v(" 正文")]),v._v(" "),t("h3",{attrs:{id:"场景1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景1","aria-hidden":"true"}},[v._v("#")]),v._v(" 场景1")]),v._v(" "),t("p",[v._v("     我需要做一个弹框表单，于是使用了"),t("code",[v._v("Element-UI")]),v._v("的"),t("code",[v._v("Dialog")]),v._v("组件嵌套"),t("code",[v._v("Form")]),v._v("组件，（表单需要校验非空），到这里是没有问题的。但当我自己测试时发现先点"),t("code",[v._v("新增表单")]),v._v("然后出发非空校验提示，之后关闭表单再打开"),t("code",[v._v("编辑表单")]),v._v("时就会出问题————上一次的校验结果没有清空，导致本来有值的项还是会提示为空。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img.fog3211.com/SW%60~7MYGVI_I%7BP4L%25@91BJY.gif",alt:"avatar"}})]),v._v(" "),t("p",[v._v("     对于上面的问题的解决思路很简单————每次都使用"),t("code",[v._v("resetFields()")]),v._v("校验结果的进行清空即可。那么问题来了，清空操作应该放在关闭上一个表单时还是新开表单时？"),t("br"),v._v("\n我的第一想法是后者，但是后来发现新开表单时dom并不能及时挂载（即使设置了this.$nextTick）后来看到有文章说是因为"),t("code",[v._v("Dialog")]),v._v("和"),t("code",[v._v("Form")]),v._v("两个dom挂载的时间不一致导致的，因此当"),t("code",[v._v("Dialog")]),v._v("打开时触发"),t("code",[v._v("resetFields()")]),v._v("，但使用的是Form的方法（此时Form为挂载，因此通过ref获取不到），所以会出现报错。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img.fog3211.com/G%25B12O1LF~4IJHG9UM.png",alt:"avatar"}})]),v._v(" "),t("p",[v._v("    报错的原因就是因为打开弹框的时候获取不到dom节点，当然这时可能会想到"),t("code",[v._v("this.$nextTick")]),v._v("（然而并无作用。。。），其实有种懒一点的解决方案就是设置定时器（这里我试了下0.5s就可以），但是随着表单的增加这种方法毕竟不牢靠。")]),v._v(" "),t("p",[v._v("    对于这种问题的解决方案：在表单关闭时触发close事件(而不是打开表单的open事件)清空校验结果，其原理就是因为当打开表单时dom没有挂载完成，因此会出问题；但关闭的时候清空校验结果，这时dom还没有卸载，因此可以先清空校验结果。")]),v._v(" "),t("h3",{attrs:{id:"场景2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景2","aria-hidden":"true"}},[v._v("#")]),v._v(" 场景2")]),v._v(" "),t("p",[v._v("     接上面的例子，如果我想设置一个复杂的表单（item多于10），并且有些项不想被编辑（比如说新增时有10项，而编辑时只显示8项）。而这时我们会面对着使用"),t("code",[v._v("v-if")]),v._v("还是"),t("code",[v._v("v-show")]),v._v("来控制显隐。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img.fog3211.com/%25A8JBM$%7BDXNU1JD%7DQ%60UDT22.png",alt:"avatar"}})]),v._v(" "),t("p",[v._v("    上图是使用v-if来进行控制时报的错（当然这个问题并不常见，一般需要比较复杂的dom结构），使用v-if来控制时，如果先点击编辑（显示8项），再点击新增（显示10项）关闭时则会报错。")]),v._v(" "),t("p",[v._v("    原理分析：当表单结构比较复杂时，使用"),t("code",[v._v("v-if")]),v._v("来控制显隐会出现dom增删操作频繁，此时获取dom就很有可能获取不到。")]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("引用官网解释：")]),v._v(" "),t("blockquote",[t("p",[v._v("v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。")]),v._v(" "),t("p",[v._v("v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。")]),v._v(" "),t("p",[v._v("相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。")]),v._v(" "),t("p",[v._v("一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好")])]),v._v(" "),t("p",[v._v("    对于"),t("code",[v._v("v-if")]),v._v("和"),t("code",[v._v("v-show")]),v._v("，之前我的理解仅仅是以为"),t("code",[v._v("v-show")]),v._v("是css层面的，"),t("code",[v._v("v-if")]),v._v("是html层面的（虽然就是这样）。出于懒惰一般惯用v-if，但是经过复杂项目的洗礼后才知道原来v-if也不是随便用的。")]),v._v(" "),t("h3",{attrs:{id:"结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论","aria-hidden":"true"}},[v._v("#")]),v._v(" 结论")]),v._v(" "),t("p",[v._v("    对于可能频繁切换或涉及到复杂dom时可以采用"),t("code",[v._v("v-show")]),v._v("来控制显隐开销；而对于切换不太频繁或者像是移动端展示最好还是使用"),t("code",[v._v("v-if")]),v._v("来节省性能。")])])}],!1,null,null,null);_.default=a.exports}}]);